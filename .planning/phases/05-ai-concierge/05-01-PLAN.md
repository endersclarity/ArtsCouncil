---
phase: 05-ai-concierge
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - scripts/build-chat-knowledge-pack.js
  - website/cultural-map-redesign/chat-knowledge-pack.json
  - website/cultural-map-redesign/api/chat.js
  - website/cultural-map-redesign/package.json
  - website/cultural-map-redesign/vercel.json
autonomous: true
user_setup:
  - service: Google Gemini API
    why: "LLM for chat responses"
    env_vars:
      - name: GEMINI_API_KEY
        source: "Google AI Studio (aistudio.google.com) -> Get API Key"
    dashboard_config: []
  - service: Supabase
    why: "Anonymous query logging"
    env_vars:
      - name: SUPABASE_URL
        source: "Supabase Dashboard -> Settings -> API -> Project URL"
      - name: SUPABASE_ANON_KEY
        source: "Supabase Dashboard -> Settings -> API -> anon public key"
    dashboard_config:
      - task: "Create chat_logs table using SQL provided in task action"
        location: "Supabase Dashboard -> SQL Editor"

must_haves:
  truths:
    - "POST /api/chat with a messages array returns a JSON response containing Gemini output"
    - "chat-knowledge-pack.json contains compressed asset index, MUSE editorials, itinerary summaries, and event titles"
    - "The serverless function strips HTML/script tags from user input before forwarding to Gemini"
    - "Off-topic queries receive a polite redirect response (Gemini system prompt enforces tourism-only scope)"
  artifacts:
    - path: "scripts/build-chat-knowledge-pack.js"
      provides: "Knowledge pack build script"
      min_lines: 60
    - path: "website/cultural-map-redesign/chat-knowledge-pack.json"
      provides: "Compressed context for Gemini system prompt"
      contains: "assets"
    - path: "website/cultural-map-redesign/api/chat.js"
      provides: "Vercel Serverless Function proxying to Gemini"
      min_lines: 80
    - path: "website/cultural-map-redesign/package.json"
      provides: "Node dependencies for serverless function"
      contains: "@google/generative-ai"
  key_links:
    - from: "scripts/build-chat-knowledge-pack.js"
      to: "website/cultural-map-redesign/chat-knowledge-pack.json"
      via: "reads data.json + muse_editorials.json + itineraries.json + events-merged-flat.json, writes compressed JSON"
      pattern: "writeFileSync.*chat-knowledge-pack"
    - from: "website/cultural-map-redesign/api/chat.js"
      to: "website/cultural-map-redesign/chat-knowledge-pack.json"
      via: "require() at module scope for cold-start caching"
      pattern: "require.*chat-knowledge-pack"
---

<objective>
Build the server-side infrastructure for the AI Concierge: a knowledge pack build script that compresses the full corpus into a ~35k-token system prompt, and a Vercel Serverless Function that proxies user queries to Gemini 2.0 Flash with input sanitization, off-topic rejection, and Supabase query logging.

Purpose: The serverless function is the backbone — it hides the Gemini API key, enforces the tourism-only system prompt, sanitizes input, and logs queries. The knowledge pack ensures Gemini has enough context to give grounded answers without sending the full 414KB data.json every request.

Output: Working `/api/chat` endpoint + `chat-knowledge-pack.json` + `package.json` with dependencies.
</objective>

<execution_context>
@C:/Users/ender/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ender/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-ai-concierge/05-RESEARCH.md

Source data files:
@website/cultural-map-redesign/data.json
@website/cultural-map-redesign/muse_editorials.json
@website/cultural-map-redesign/itineraries.json
@website/cultural-map-redesign/events-merged-flat.json
@website/cultural-map-redesign/experiences.json
@website/cultural-map-redesign/vercel.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Build knowledge pack script and generate compressed JSON</name>
  <files>
    scripts/build-chat-knowledge-pack.js
    website/cultural-map-redesign/chat-knowledge-pack.json
  </files>
  <action>
Create `scripts/build-chat-knowledge-pack.js` (Node.js, no external deps) that reads 4 source files and outputs `website/cultural-map-redesign/chat-knowledge-pack.json`.

**Asset index compression (data.json → ~20k tokens):**
- Read `website/cultural-map-redesign/data.json` (685 assets)
- For each asset, emit ONLY: `n` (name), `l` (layer/category), `c` (city), `d` (description truncated to 80 chars), `w` (website), `h` (hours — keep as-is for "Open Now" reasoning)
- DROP: coordinates (`x`, `y`), phone (`p`), address (`a`), event count (`e`)
- The asset's position in the array IS its index (Gemini can reference by name, not by pid — the client will fuzzy-match name→pid)

**MUSE editorials (muse_editorials.json → ~4k tokens):**
- Include full content (already small)

**Itinerary summaries (itineraries.json → ~3k tokens):**
- For each itinerary: `id`, `title`, `subtitle`, `duration`, and array of stop names (just the `name` field from each stop)
- DROP: narratives, coordinates, tips, timing details

**Event titles (events-merged-flat.json → ~7k tokens):**
- For each event: `title`, `venue` (or location), `city`, `start_date` (ISO string), `source`
- DROP: descriptions, URLs, images, end dates, tags

**Output structure:**
```json
{
  "generated": "2026-02-15T...",
  "assets": [...compressed...],
  "muse_editorials": [...full...],
  "itineraries": [...summary...],
  "events": [...title+venue+date...],
  "stats": { "asset_count": 685, "event_count": 176, "itinerary_count": 3 }
}
```

Run the script after creation: `node scripts/build-chat-knowledge-pack.js`
Verify the output JSON exists and is under 200KB.
  </action>
  <verify>
Run: `node scripts/build-chat-knowledge-pack.js && node -e "const d=require('./website/cultural-map-redesign/chat-knowledge-pack.json'); console.log('assets:', d.assets.length, 'events:', d.events.length, 'itineraries:', d.itineraries.length, 'size:', JSON.stringify(d).length, 'bytes')"`
Expected: assets ~685, events ~176, itineraries 3, size under 200000 bytes
  </verify>
  <done>chat-knowledge-pack.json exists with all 4 data sections populated, under 200KB, generated timestamp present</done>
</task>

<task type="auto">
  <name>Task 2: Create Vercel Serverless Function, package.json, and update vercel.json</name>
  <files>
    website/cultural-map-redesign/api/chat.js
    website/cultural-map-redesign/package.json
    website/cultural-map-redesign/vercel.json
  </files>
  <action>
**1. Create `website/cultural-map-redesign/package.json`:**
```json
{
  "private": true,
  "dependencies": {
    "@google/generative-ai": "^0.24.0",
    "@supabase/supabase-js": "^2.49.0"
  }
}
```

**2. Create `website/cultural-map-redesign/api/chat.js`:**

Vercel Serverless Function (CommonJS, Node 18+). Structure:

```javascript
const { GoogleGenerativeAI } = require("@google/generative-ai");
const { createClient } = require("@supabase/supabase-js");
const knowledgePack = require("../chat-knowledge-pack.json");
```

**Request handling:**
- Only accept POST. Return 405 for other methods.
- Parse body: `{ messages: [{role: "user"|"model", content: string}], sessionHash: string }`
- Validate: messages must be array, 1-20 items, each with string role and content
- Sanitize each message content: strip HTML tags (`/<[^>]*>/g`), strip `javascript:` and `on\w+=` patterns, enforce 500-char max per message

**System prompt construction:**
Build from knowledgePack. The system prompt must include:
1. Role: "You are a friendly local concierge for Nevada County, California. You help visitors discover restaurants, galleries, performances, trails, museums, and cultural experiences."
2. Boundaries: "You ONLY answer questions about Nevada County tourism, dining, arts, events, history, and travel. Refuse any request unrelated to this scope with: 'I'm your Nevada County concierge! I can help you find restaurants, galleries, events, and things to do around here. What are you looking for?'"
3. Response format instructions: "When mentioning a specific place from the asset list, format as [[Place Name|place-name-slug]]. When citing MUSE magazine content, format as {{MUSE|article-id|brief quote}}."
4. The full compressed asset list (JSON.stringify knowledgePack.assets)
5. MUSE editorial content (JSON.stringify knowledgePack.muse_editorials)
6. Itinerary summaries (JSON.stringify knowledgePack.itineraries)
7. Event listings with note: "Event data last updated: {knowledgePack.generated}. Recommend visitors verify event details."
8. Freshness disclaimer: "Business hours and availability may have changed. Suggest visitors verify with the venue."

**Gemini call:**
- Initialize `GoogleGenerativeAI` with `process.env.GEMINI_API_KEY`
- Model: `gemini-2.0-flash`
- Use `startChat()` with history = all messages except the last one (convert role "model" to Gemini's expected format)
- Send last message via `sendMessage()`
- Extract text from response

**Supabase logging (fire-and-forget):**
- Initialize Supabase client with `process.env.SUPABASE_URL` and `process.env.SUPABASE_ANON_KEY`
- Only log if both env vars are set (graceful skip if not configured)
- Insert into `chat_logs`: session_hash, query_text (last user message), response_text (first 2000 chars), duration_ms (Date.now() delta), model: "gemini-2.0-flash"
- Use `.catch(() => {})` — never let logging failure break the response

**Rate limiting (simple):**
- If Supabase is configured, before calling Gemini: count rows in chat_logs for this sessionHash in last 5 minutes
- If count > 20, return 429 with message "Too many requests. Please wait a moment."
- If Supabase not configured, skip rate limiting

**Error handling:**
- Gemini API errors: return 502 with generic message "Sorry, I'm having trouble thinking right now. Please try again."
- Validation errors: return 400 with specific message
- Wrap everything in try/catch, return 500 for unexpected errors

**3. Update `website/cultural-map-redesign/vercel.json`:**
Add CORS headers for the API endpoint. Keep existing redirects. Add:
```json
{
  "headers": [
    {
      "source": "/api/(.*)",
      "headers": [
        { "key": "Access-Control-Allow-Origin", "value": "*" },
        { "key": "Access-Control-Allow-Methods", "value": "POST, OPTIONS" },
        { "key": "Access-Control-Allow-Headers", "value": "Content-Type" }
      ]
    }
  ]
}
```

**4. Provide Supabase SQL in plan output (for user_setup):**
The executor should print the following SQL for the user to run in Supabase SQL Editor:
```sql
CREATE TABLE public.chat_logs (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  session_hash TEXT NOT NULL,
  query_text TEXT NOT NULL,
  response_text TEXT,
  intent TEXT,
  assets_referenced TEXT[],
  duration_ms INTEGER,
  model TEXT NOT NULL DEFAULT 'gemini-2.0-flash',
  ip_hash TEXT,
  meta JSONB
);
ALTER TABLE public.chat_logs ENABLE ROW LEVEL SECURITY;
CREATE POLICY "allow_insert_only" ON public.chat_logs FOR INSERT TO anon WITH CHECK (true);
CREATE POLICY "deny_select" ON public.chat_logs FOR SELECT TO anon USING (false);
CREATE INDEX idx_chat_logs_created ON public.chat_logs (created_at DESC);
CREATE INDEX idx_chat_logs_intent ON public.chat_logs (intent);
```
  </action>
  <verify>
1. Verify api/chat.js exists and exports a handler: `node -e "const h = require('./website/cultural-map-redesign/api/chat.js'); console.log(typeof h)"`
   Expected: "function"
2. Verify package.json has both dependencies: `node -e "const p = require('./website/cultural-map-redesign/package.json'); console.log(Object.keys(p.dependencies))"`
   Expected: ["@google/generative-ai", "@supabase/supabase-js"]
3. Verify vercel.json has CORS headers and existing redirects: `node -e "const v = require('./website/cultural-map-redesign/vercel.json'); console.log('redirects:', v.redirects.length, 'headers:', !!v.headers)"`
   Expected: redirects: 3, headers: true
  </verify>
  <done>api/chat.js is a valid Vercel Serverless Function that proxies to Gemini 2.0 Flash with the knowledge pack as system prompt, sanitizes input, enforces tourism-only scope, logs to Supabase, and rate-limits by session. package.json declares both dependencies. vercel.json has CORS headers for /api/* routes.</done>
</task>

</tasks>

<verification>
1. Knowledge pack JSON exists at website/cultural-map-redesign/chat-knowledge-pack.json with all 4 sections
2. api/chat.js exports a function handler
3. package.json lists @google/generative-ai and @supabase/supabase-js
4. vercel.json retains all 3 redirects AND adds CORS headers for /api/*
5. Build script is idempotent (running twice produces same output)
</verification>

<success_criteria>
- `node scripts/build-chat-knowledge-pack.js` produces valid JSON under 200KB
- api/chat.js can be `require()`'d without errors
- package.json is valid JSON with both dependencies
- vercel.json merges CORS headers with existing redirect config
</success_criteria>

<output>
After completion, create `.planning/phases/05-ai-concierge/05-01-SUMMARY.md`
</output>
